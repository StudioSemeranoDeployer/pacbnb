<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PacBnb | ApulianChain Global</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        :root {
            --bnb-yellow: #F0B90B;
            --bg-dark: #11151c; /* Sfondo leggermente più chiaro */
            --glass: rgba(30, 30, 40, 0.8);
            --neon-blue: #00f2ff;
            --win-green: #00ff88;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: 'Inter', system-ui, sans-serif; color: white; user-select: none; }
        
        /* CRT SCANLINE EFFECT (Ridotto per visibilità) */
        body::after {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.05) 50%);
            background-size: 100% 4px; z-index: 50; pointer-events: none;
        }

        /* HUD SUPERIORE */
        #hud {
            position: absolute; top: 0; left: 0; right: 0; padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start; z-index: 100;
        }
        .stat-card {
            background: var(--glass); backdrop-filter: blur(12px);
            padding: 10px 20px; border-radius: 8px; border-left: 3px solid var(--bnb-yellow);
            box-shadow: 0 4px 30px rgba(0,0,0,0.5);
        }
        .label { font-size: 10px; color: #ccc; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; }
        .value { font-size: 20px; font-weight: 800; color: white; font-variant-numeric: tabular-nums; }
        
        /* PULSANTE WEB3 */
        .btn-connect {
            background: var(--bnb-yellow); color: black; border: none; padding: 10px 20px;
            font-weight: 800; border-radius: 4px; cursor: pointer; text-transform: uppercase; font-size: 12px;
            box-shadow: 0 0 15px rgba(240, 185, 11, 0.4); transition: 0.3s;
        }
        .btn-connect:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(240, 185, 11, 0.6); }

        /* SCREENS */
        .overlay {
            position: absolute; inset: 0; background: rgba(5, 7, 10, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; text-align: center; transition: opacity 0.5s;
        }
        .title-glitch { font-size: 48px; font-weight: 900; color: var(--bnb-yellow); text-shadow: 2px 2px 0px #ff00de, -2px -2px 0px #00f2ff; margin-bottom: 10px; }
        
        .start-btn {
            background: transparent; border: 2px solid var(--bnb-yellow); color: var(--bnb-yellow);
            padding: 15px 50px; font-size: 18px; font-weight: bold; letter-spacing: 3px;
            margin-top: 30px; cursor: pointer; transition: 0.3s;
        }
        .start-btn:hover { background: var(--bnb-yellow); color: black; }
        
        .hidden { opacity: 0; pointer-events: none; }
        
        /* WIN SCREEN SPECIFIC */
        #win-screen .title-glitch { color: var(--win-green); text-shadow: 0 0 20px var(--win-green); }
        #win-screen .start-btn { border-color: var(--win-green); color: var(--win-green); }
        #win-screen .start-btn:hover { background: var(--win-green); color: black; }

        /* FOOTER BRANDING */
        #footer {
            position: absolute; bottom: 0; left: 0; right: 0; height: 60px;
            background: linear-gradient(to top, #000 0%, transparent 100%);
            display: flex; justify-content: center; align-items: center; gap: 30px;
            z-index: 100; padding-bottom: 10px; opacity: 0.9;
        }
        .brand { font-size: 10px; font-weight: 600; letter-spacing: 2px; color: #888; display: flex; align-items: center; gap: 6px; }
        .brand span { color: var(--bnb-yellow); }
        .brand.highlight { color: white; }

    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-card">
            <div class="label">Balance (Score)</div>
            <div id="score-display" class="value">0.00 BNB</div>
        </div>
        <button id="web3-btn" class="btn-connect" onclick="connectWallet()">Connect Wallet</button>
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="overlay">
        <div class="title-glitch">PACBNB</div>
        <p style="color: #ccc; letter-spacing: 1px;">DEFI GAMIFIED EXPERIENCE</p>
        <button class="start-btn" onclick="startGame()">INITIALIZE</button>
        <p style="font-size: 10px; color: #666; margin-top: 20px;">TOUCH TO MOVE • EAT CRYPTO • AVOID ALTS</p>
    </div>

    <!-- WIN SCREEN -->
    <div id="win-screen" class="overlay hidden">
        <div class="title-glitch">MISSION COMPLETE</div>
        <p style="color: #fff; letter-spacing: 1px; font-size: 18px;">ALL LIQUIDITY DRAINED!</p>
        <div id="final-score" style="font-size: 24px; font-weight: bold; margin: 15px 0; color: #F0B90B;"></div>
        <button class="start-btn" onclick="location.reload()">MINT NEXT LEVEL</button>
    </div>

    <div id="footer">
        <div class="brand highlight">POWERED BY <span>APULIANCHAIN</span></div>
        <div style="width: 1px; height: 15px; background: #555;"></div>
        <div class="brand"><span>BINANCE</span> SMART CHAIN</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const TILE_SIZE = 10;
        const PLAYER_SPEED = 0.25;
        // Increase enemy speed (Previous was 0.15). 
        // 0.22 is very fast relative to tiles (almost as fast as player).
        const GHOST_SPEED = 0.22; 
        
        let score = 0;
        let isRunning = false;
        let activeCoins = 0; // Contatore monete per la vittoria

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        // Nebbia ridotta e colore più chiaro per visibilità
        scene.fog = new THREE.FogExp2(0x11151c, 0.008); 
        scene.background = new THREE.Color(0x11151c);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); // Removed alpha for solid bg color
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (MIGLIORATA PER VISIBILITÀ) ---
        // Luce ambientale molto più forte
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
        scene.add(ambientLight);

        // Luce direzionale (Sole) più intensa
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(30, 60, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);
        
        // Luce emisferica per riempire le ombre
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444466, 0.8);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        
        // --- MAP GENERATION ---
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,0,0,0,1,8,8,8,1,0,0,0,1],
            [1,0,1,0,1,0,0,0,1,0,1,0,1],
            [1,0,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,9,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const walls = [];
        const coins = [];
        const ghosts = [];
        let player;
        let nextDir = new THREE.Vector3(0, 0, 0);
        let currentDir = new THREE.Vector3(0, 0, 0);

        function createLevel() {
            // Muri più chiari
            const wallGeo = new THREE.BoxGeometry(TILE_SIZE, 8, TILE_SIZE);
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x444952, // Grigio più chiaro
                roughness: 0.2, 
                metalness: 0.3 
            });

            const coinColors = [0x627EEA, 0x00ff88, 0x9945FF];

            mapLayout.forEach((row, z) => {
                row.forEach((type, x) => {
                    const posX = (x - 6) * TILE_SIZE;
                    const posZ = (z - 4) * TILE_SIZE;

                    if (type === 1) {
                        // MURO
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(posX, 4, posZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        
                        // Bordi più visibili
                        const edges = new THREE.LineSegments(
                            new THREE.EdgesGeometry(wallGeo), 
                            new THREE.LineBasicMaterial({ color: 0x888899 })
                        );
                        wall.add(edges);
                        walls.push(new THREE.Box3().setFromObject(wall));
                    } 
                    else if (type === 0 || type === 9 || type === 8) {
                        // MONETE
                        if (type === 0 || type === 9) {
                            const coinGeo = new THREE.OctahedronGeometry(1.5);
                            const color = coinColors[Math.floor(Math.random() * coinColors.length)];
                            const coinMat = new THREE.MeshStandardMaterial({ 
                                color: color, 
                                emissive: color, 
                                emissiveIntensity: 1, // Più brillante
                                metalness: 0.9,
                                roughness: 0.1
                            });
                            const coin = new THREE.Mesh(coinGeo, coinMat);
                            coin.position.set(posX, 3, posZ);
                            scene.add(coin);
                            coins.push(coin);
                            activeCoins++; // Conta monete totali
                        }
                    }

                    // PLAYER
                    if (type === 9) {
                        const playerGeo = new THREE.SphereGeometry(3.5, 32, 32);
                        const playerMat = new THREE.MeshStandardMaterial({ 
                            color: 0xF0B90B, 
                            emissive: 0xF0B90B, 
                            emissiveIntensity: 0.4,
                            metalness: 0.7, 
                            roughness: 0.1 
                        });
                        player = new THREE.Mesh(playerGeo, playerMat);
                        player.position.set(posX, 3.5, posZ);
                        
                        const pLight = new THREE.PointLight(0xF0B90B, 800, 60);
                        player.add(pLight);
                        
                        scene.add(player);
                    }

                    // GHOST
                    if (type === 8) {
                        const ghostGroup = new THREE.Group();
                        const body = new THREE.Mesh(
                            new THREE.CapsuleGeometry(2.5, 3, 4, 8),
                            new THREE.MeshStandardMaterial({ color: 0xff0044, emissive: 0xff0044, emissiveIntensity: 0.8 })
                        );
                        body.position.y = 3;
                        ghostGroup.add(body);
                        
                        // Eyes
                        const eyeGeo = new THREE.SphereGeometry(0.8);
                        const eyeMat = new THREE.MeshBasicMaterial({color: 0xffffff});
                        const eye = new THREE.Mesh(eyeGeo, eyeMat);
                        eye.position.set(1, 4, 1.5);
                        ghostGroup.add(eye);
                        const eye2 = eye.clone();
                        eye2.position.set(-1, 4, 1.5);
                        ghostGroup.add(eye2);

                        ghostGroup.position.set(posX, 0, posZ);
                        // Direzione iniziale random
                        const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0)];
                        ghostGroup.userData = { dir: dirs[Math.floor(Math.random()*dirs.length)] };
                        ghosts.push(ghostGroup);
                        scene.add(ghostGroup);
                    }
                });
            });
            
            // Camera position
            camera.position.set(0, 110, 60);
            camera.lookAt(0, 0, 10);
        }

        // --- GAME LOGIC ---
        function update() {
            if (!isRunning) return;

            // 1. Movimento Player
            const intendedPos = player.position.clone().add(nextDir.clone().multiplyScalar(PLAYER_SPEED * TILE_SIZE));
            if (!checkWallCollision(intendedPos)) {
                currentDir.copy(nextDir);
            }
            
            const nextPos = player.position.clone().add(currentDir.clone().multiplyScalar(PLAYER_SPEED));
            if (!checkWallCollision(nextPos)) {
                player.position.copy(nextPos);
                if(currentDir.length() > 0) {
                    player.lookAt(player.position.clone().add(currentDir));
                }
            }

            // 2. Collisione Monete & Vittoria
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.rotation.y += 0.05; 
                coin.position.y = 3 + Math.sin(Date.now() * 0.005) * 0.5; // Hover effect

                if (coin.visible && player.position.distanceTo(coin.position) < 5) {
                    coin.visible = false;
                    score += 0.10;
                    activeCoins--;
                    document.getElementById('score-display').innerText = score.toFixed(2) + " BNB";
                    
                    // CHECK WIN CONDITION
                    if (activeCoins <= 0) {
                        gameWin();
                    }
                }
            }

            // 3. Nemici AI (Bounce Logic)
            ghosts.forEach(g => {
                const gNext = g.position.clone().add(g.userData.dir.clone().multiplyScalar(GHOST_SPEED));
                
                let hitWall = false;
                // Collision box per fantasmi leggermente più permissiva
                const gBox = new THREE.Box3().setFromCenterAndSize(gNext.clone().add(new THREE.Vector3(0,3,0)), new THREE.Vector3(6,6,6));
                
                for(let w of walls) {
                    if(gBox.intersectsBox(w)) hitWall = true;
                }

                // Limiti mappa
                if (Math.abs(gNext.x) > 80 || Math.abs(gNext.z) > 60) hitWall = true;

                if(!hitWall) {
                    g.position.copy(gNext);
                    g.lookAt(g.position.clone().add(g.userData.dir));
                } else {
                    // Cambia direzione se colpisce muro
                    const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
                    // Filtra la direzione opposta per evitare che torni indietro subito (opzionale, ma migliora AI)
                    const availableDirs = dirs.filter(d => !d.equals(g.userData.dir.clone().negate()));
                    g.userData.dir = availableDirs[Math.floor(Math.random()*availableDirs.length)];
                }

                // Kill Player
                if(player.position.distanceTo(g.position) < 5) {
                    gameOver();
                }
            });
        }

        function checkWallCollision(position) {
            const pBox = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(6, 6, 6));
            for (const wallBox of walls) {
                if (pBox.intersectsBox(wallBox)) return true;
            }
            return false;
        }

        function gameOver() {
            isRunning = false;
            // Delay leggero per evitare alert immediato
            setTimeout(() => {
                alert("RUG PULL! You got liquidated. Score: " + score.toFixed(2) + " BNB");
                location.reload();
            }, 100);
        }

        function gameWin() {
            isRunning = false;
            document.getElementById('final-score').innerText = "PROFIT: " + score.toFixed(2) + " BNB";
            document.getElementById('win-screen').classList.remove('hidden');
        }

        // --- CONTROLS ---
        window.addEventListener('keydown', (e) => {
            if(e.key === "ArrowUp" || e.key === "w") nextDir.set(0, 0, -1);
            if(e.key === "ArrowDown" || e.key === "s") nextDir.set(0, 0, 1);
            if(e.key === "ArrowLeft" || e.key === "a") nextDir.set(-1, 0, 0);
            if(e.key === "ArrowRight" || e.key === "d") nextDir.set(1, 0, 0);
        });

        window.addEventListener('touchstart', (e) => {
            const x = e.touches[0].clientX / window.innerWidth;
            const y = e.touches[0].clientY / window.innerHeight;
            if (y < 0.3) nextDir.set(0, 0, -1);
            else if (y > 0.7) nextDir.set(0, 0, 1);
            else if (x < 0.5) nextDir.set(-1, 0, 0);
            else nextDir.set(1, 0, 0);
        });

        // --- INIT ---
        window.startGame = () => {
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('start-screen').classList.add('hidden');
                isRunning = true;
            }, 500);
        };

        window.connectWallet = async () => {
            const btn = document.getElementById('web3-btn');
            btn.innerText = "Connecting...";
            if(window.ethereum) {
                try {
                    const provider = new ethers.BrowserProvider(window.ethereum);
                    const signer = await provider.getSigner();
                    const addr = await signer.getAddress();
                    btn.innerText = addr.substring(0,6) + "...";
                    btn.style.background = "#00ff88";
                } catch(e) {
                    btn.innerText = "Error";
                }
            } else {
                alert("MetaMask not found!");
                btn.innerText = "Connect Wallet";
            }
        };

        createLevel();
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
