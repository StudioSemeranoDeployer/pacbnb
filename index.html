<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PacBnb Mobile Deluxe</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        :root {
            --bnb-yellow: #F0B90B;
            --bg-dark: #0a0b10;
            --glass: rgba(20, 20, 25, 0.8);
            --win-green: #00ff88;
        }
        
        body { 
            margin: 0; overflow: hidden; background: var(--bg-dark); 
            font-family: 'Inter', system-ui, sans-serif; color: white; 
            user-select: none; touch-action: none;
        }

        /* HUD */
        #hud {
            position: absolute; top: 0; left: 0; right: 0; padding: 15px;
            display: flex; justify-content: space-between; align-items: flex-start; z-index: 100;
            pointer-events: none;
        }
        .stat-card {
            background: var(--glass); backdrop-filter: blur(5px);
            padding: 8px 15px; border-radius: 8px; border-left: 3px solid var(--bnb-yellow);
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .value { font-size: 18px; font-weight: 800; color: white; text-shadow: 0 0 10px rgba(240, 185, 11, 0.5); }
        
        .btn-connect {
            pointer-events: auto;
            background: var(--bnb-yellow); color: black; border: none; padding: 8px 15px;
            font-weight: 800; border-radius: 4px; text-transform: uppercase; font-size: 11px;
            box-shadow: 0 0 15px rgba(240, 185, 11, 0.3);
        }

        /* D-PAD */
        #controls {
            position: absolute; bottom: 30px; left: 0; right: 0;
            height: 180px; z-index: 150;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: none;
        }
        .dpad-row { display: flex; gap: 20px; }
        .dpad-btn {
            width: 70px; height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: rgba(255,255,255,0.8);
            pointer-events: auto;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .dpad-btn:active { background: var(--bnb-yellow); color: black; transform: scale(0.9); }

        /* SCREENS */
        .overlay {
            position: absolute; inset: 0; background: rgba(10, 11, 16, 0.96);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; text-align: center; transition: opacity 0.3s;
        }
        .title-glitch { font-size: 40px; font-weight: 900; color: var(--bnb-yellow); margin-bottom: 5px; text-shadow: 0 0 20px rgba(240,185,11,0.4); }
        .start-btn {
            background: transparent; border: 2px solid var(--bnb-yellow); color: var(--bnb-yellow);
            padding: 15px 40px; font-size: 16px; font-weight: bold; letter-spacing: 2px;
            margin-top: 30px; cursor: pointer; touch-action: manipulation;
            box-shadow: 0 0 15px rgba(240, 185, 11, 0.2);
        }
        .hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat-card">
            <div class="value" id="score-display">0.00 BNB</div>
        </div>
        <button id="web3-btn" class="btn-connect" onclick="connectWallet()">Wallet</button>
    </div>

    <div id="controls">
        <div class="dpad-row" style="margin-bottom: 15px;">
            <div class="dpad-btn" id="btn-up">▲</div>
        </div>
        <div class="dpad-row">
            <div class="dpad-btn" id="btn-left">◀</div>
            <div class="dpad-btn" id="btn-down">▼</div>
            <div class="dpad-btn" id="btn-right">▶</div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <div class="title-glitch">PACBNB</div>
        <p style="color: #666; font-size: 12px; letter-spacing: 3px;">DEFI PROTOCOL INITIALIZED</p>
        <button class="start-btn" onclick="startGame()">START MINING</button>
    </div>

    <div id="win-screen" class="overlay hidden">
        <div class="title-glitch" style="color: var(--win-green);">SYSTEM DRAINED</div>
        <div id="final-score" style="font-size: 20px; color: white; margin: 15px 0;"></div>
        <button class="start-btn" style="border-color: var(--win-green); color: var(--win-green);" onclick="location.reload()">NEXT BLOCK</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const TILE_SIZE = 10;
        const PLAYER_SPEED = 0.25;
        const GHOST_SPEED = 0.22; 
        
        let score = 0;
        let isRunning = false;
        let activeCoins = 0;

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0b10); // Darker cyber background
        scene.fog = new THREE.FogExp2(0x0a0b10, 0.006); // Soft fog

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- IMPROVEMENT 1: CYBER GRID FLOOR ---
        const gridHelper = new THREE.GridHelper(200, 20, 0x333333, 0x111111);
        gridHelper.position.y = 0;
        scene.add(gridHelper);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(20, 80, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Neon ambient glow
        const hemiLight = new THREE.HemisphereLight(0x00f2ff, 0xff0088, 0.3); 
        scene.add(hemiLight);

        // --- GAME ASSETS ---
        const walls = [];
        const coins = [];
        const ghosts = [];
        let particles = []; // Array per le esplosioni
        let player;
        let nextDir = new THREE.Vector3(0, 0, 0);
        let currentDir = new THREE.Vector3(0, 0, 0);

        // Mappa
        const mapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,0,0,0,1,8,8,8,1,0,0,0,1],
            [1,0,1,0,1,0,0,0,1,0,1,0,1],
            [1,0,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,9,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        function createLevel() {
            // IMPROVEMENT 3: NEON GLASS WALLS
            const wallGeo = new THREE.BoxGeometry(TILE_SIZE, 6, TILE_SIZE);
            const wallMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x111111, 
                metalness: 0.8, 
                roughness: 0.2,
                transparent: true,
                opacity: 0.9,
                transmission: 0.2 // Glass effect
            });
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x00f2ff, opacity: 0.3, transparent: true });

            mapLayout.forEach((row, z) => {
                row.forEach((type, x) => {
                    const posX = (x - 6) * TILE_SIZE;
                    const posZ = (z - 4) * TILE_SIZE;

                    if (type === 1) {
                        const wall = new THREE.Mesh(wallGeo, wallMat);
                        wall.position.set(posX, 3, posZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        
                        // Neon Edges
                        const edges = new THREE.LineSegments(new THREE.EdgesGeometry(wallGeo), edgeMat);
                        wall.add(edges);
                        
                        walls.push(new THREE.Box3().setFromObject(wall));
                    } 
                    else if (type === 0 || type === 9) {
                        if (type === 0 || type === 9) {
                            const coinGeo = new THREE.OctahedronGeometry(1.5);
                            const coinMat = new THREE.MeshStandardMaterial({ 
                                color: 0xF0B90B, 
                                emissive: 0xF0B90B, 
                                emissiveIntensity: 0.8,
                                metalness: 1,
                                roughness: 0
                            });
                            const coin = new THREE.Mesh(coinGeo, coinMat);
                            coin.position.set(posX, 3, posZ);
                            scene.add(coin);
                            coins.push(coin);
                            activeCoins++;
                        }
                    }

                    if (type === 9) {
                        // PLAYER
                        const playerGeo = new THREE.SphereGeometry(3.5, 32, 32);
                        const playerMat = new THREE.MeshStandardMaterial({ 
                            color: 0xF0B90B, 
                            emissive: 0xF0B90B,
                            emissiveIntensity: 0.5,
                            metalness: 0.5, 
                            roughness: 0.1 
                        });
                        player = new THREE.Mesh(playerGeo, playerMat);
                        player.position.set(posX, 3.5, posZ);
                        
                        // Luce più intensa
                        const pLight = new THREE.PointLight(0xF0B90B, 400, 35);
                        player.add(pLight);
                        scene.add(player);
                    }

                    if (type === 8) {
                        // GHOST
                        const ghostGroup = new THREE.Group();
                        const body = new THREE.Mesh(
                            new THREE.CapsuleGeometry(2.5, 3, 4, 8),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xff0055, 
                                emissive: 0xff0055, 
                                emissiveIntensity: 0.6 
                            })
                        );
                        body.position.y = 3;
                        ghostGroup.add(body);
                        
                        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({color:0xffffff}));
                        eye.position.set(1, 4, 1.5);
                        ghostGroup.add(eye);
                        const eye2 = eye.clone();
                        eye2.position.set(-1, 4, 1.5);
                        ghostGroup.add(eye2);

                        // Ghost Light (Red glow)
                        const gLight = new THREE.PointLight(0xff0055, 100, 15);
                        gLight.position.y = 3;
                        ghostGroup.add(gLight);

                        ghostGroup.position.set(posX, 0, posZ);
                        ghostGroup.userData = { dir: new THREE.Vector3(1,0,0) };
                        ghosts.push(ghostGroup);
                        scene.add(ghostGroup);
                    }
                });
            });
            adjustCamera();
        }

        // IMPROVEMENT 2: PARTICLE SYSTEM
        function spawnParticles(pos, color) {
            const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const material = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<8; i++) {
                const p = new THREE.Mesh(geometry, material);
                p.position.copy(pos);
                // Velocità casuale esplosiva
                p.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8,
                    (Math.random() - 0.5) * 0.8
                );
                p.userData.life = 1.0; // Vita particella
                scene.add(p);
                particles.push(p);
            }
        }

        function adjustCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1) { // Mobile
                camera.position.set(0, 85, 50); 
                camera.fov = 60;
            } else { // Desktop
                camera.position.set(0, 110, 60);
                camera.fov = 45;
            }
            camera.lookAt(0, 0, 5); 
            camera.updateProjectionMatrix();
        }

        function update() {
            if (!isRunning) return;

            // IMPROVEMENT 4: PULSE ANIMATION
            const time = Date.now() * 0.005;
            player.material.emissiveIntensity = 0.5 + Math.sin(time * 2) * 0.2;

            // Player Mov
            const intendedPos = player.position.clone().add(nextDir.clone().multiplyScalar(PLAYER_SPEED * TILE_SIZE));
            if (!checkWallCollision(intendedPos)) currentDir.copy(nextDir);
            
            const nextPos = player.position.clone().add(currentDir.clone().multiplyScalar(PLAYER_SPEED));
            if (!checkWallCollision(nextPos)) {
                player.position.copy(nextPos);
                if(currentDir.length() > 0) player.lookAt(player.position.clone().add(currentDir));
            }

            // Coin Logic
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.rotation.y += 0.05;
                coin.rotation.x += 0.02;

                if (coin.visible && player.position.distanceTo(coin.position) < 5) {
                    coin.visible = false;
                    score += 0.1;
                    activeCoins--;
                    
                    // Spawn Particles
                    spawnParticles(coin.position, 0xF0B90B);
                    
                    document.getElementById('score-display').innerText = score.toFixed(2) + " BNB";
                    if(activeCoins <= 0) gameWin();
                }
            }

            // Particle Logic
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.velocity);
                p.rotation.x += 0.1;
                p.userData.life -= 0.05;
                p.scale.setScalar(p.userData.life); // Rimpicciolisce
                
                if(p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            // Ghost AI
            ghosts.forEach(g => {
                const gNext = g.position.clone().add(g.userData.dir.clone().multiplyScalar(GHOST_SPEED));
                let hitWall = false;
                const gBox = new THREE.Box3().setFromCenterAndSize(gNext.clone().add(new THREE.Vector3(0,3,0)), new THREE.Vector3(6,6,6));
                
                walls.forEach(w => { if(gBox.intersectsBox(w)) hitWall = true; });
                if(Math.abs(gNext.x) > 85 || Math.abs(gNext.z) > 65) hitWall = true;

                if(!hitWall) {
                    g.position.copy(gNext);
                    g.lookAt(g.position.clone().add(g.userData.dir));
                } else {
                    const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
                    g.userData.dir = dirs[Math.floor(Math.random()*dirs.length)];
                }

                if(player.position.distanceTo(g.position) < 5) gameOver();
            });
        }

        function checkWallCollision(position) {
            const pBox = new THREE.Box3().setFromCenterAndSize(position, new THREE.Vector3(6, 6, 6));
            for (const wallBox of walls) {
                if (pBox.intersectsBox(wallBox)) return true;
            }
            return false;
        }

        function gameOver() {
            isRunning = false;
            setTimeout(() => {
                alert("LIQUIDATED! Score: " + score.toFixed(2));
                location.reload();
            }, 100);
        }

        function gameWin() {
            isRunning = false;
            document.getElementById('final-score').innerText = "PROFIT: " + score.toFixed(2) + " BNB";
            document.getElementById('win-screen').classList.remove('hidden');
        }

        // --- CONTROLS ---
        const setDir = (x, z, e) => {
            if(e) e.preventDefault();
            nextDir.set(x, 0, z);
        };

        const btnUp = document.getElementById('btn-up');
        const btnDown = document.getElementById('btn-down');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');

        // Touch
        btnUp.addEventListener('touchstart', (e) => setDir(0, -1, e));
        btnDown.addEventListener('touchstart', (e) => setDir(0, 1, e));
        btnLeft.addEventListener('touchstart', (e) => setDir(-1, 0, e));
        btnRight.addEventListener('touchstart', (e) => setDir(1, 0, e));
        
        // Mouse (PC testing)
        btnUp.addEventListener('mousedown', () => setDir(0, -1));
        btnDown.addEventListener('mousedown', () => setDir(0, 1));
        btnLeft.addEventListener('mousedown', () => setDir(-1, 0));
        btnRight.addEventListener('mousedown', () => setDir(1, 0));

        window.addEventListener('keydown', (e) => {
            if(e.key === "ArrowUp") nextDir.set(0, 0, -1);
            if(e.key === "ArrowDown") nextDir.set(0, 0, 1);
            if(e.key === "ArrowLeft") nextDir.set(-1, 0, 0);
            if(e.key === "ArrowRight") nextDir.set(1, 0, 0);
        });

        // INIT
        window.startGame = () => {
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('start-screen').classList.add('hidden');
                isRunning = true;
            }, 300);
        };

        window.connectWallet = async () => { alert("Wallet simulation active"); };

        createLevel();
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            adjustCamera();
        });

    </script>
</body>
</html>
